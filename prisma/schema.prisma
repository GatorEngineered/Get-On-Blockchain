generator client {
  provider = "prisma-client-js"
}

datasource db {
  // Using PostgreSQL for both local dev and production
  // DATABASE_URL should be set in .env.local and Vercel environment variables

  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Business {
  id                 String              @id @default(cuid())
  slug               String              @unique
  name               String
  locationNickname   String?
  address            String // Street address
  suite              String? // Suite/Apt/Unit number
  city               String?
  state              String? // Two-letter state code for filtering
  zipCode            String?
  contactEmail       String
  industry           String? // "restaurant", "gym", "salon", "retail"
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  merchantId         String?
  merchant           Merchant?           @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  members            BusinessMember[]
  rewardTransactions RewardTransaction[]
  qrCodes            QRCode[]
  scans              Scan[]

  @@index([state])
  @@index([industry])
}

/// *
///  * Merchant is your internal "plan" / configuration object for the SaaS.
///  * You can keep using this for pricing plans, welcome points logic, etc.
model Merchant {
  id             String  @id @default(cuid())
  slug           String  @unique
  name           String
  tagline        String?
  plan           Plan    @default(STARTER)
  loginEmail     String  @unique
  passwordHash   String
  welcomePoints  Int     @default(10)
  earnPerVisit   Int     @default(10)
  vipThreshold   Int     @default(100)
  superThreshold Int     @default(200)
  primaryColor   String?
  accentColor    String?

  // Payment & Subscription (PayPal)
  paymentVerified      Boolean            @default(false)
  paypalSubscriptionId String?            @unique
  subscriptionStatus   SubscriptionStatus @default(TRIAL)
  trialEndsAt          DateTime?
  subscriptionEndsAt   DateTime?
  cancelAtPeriodEnd    Boolean            @default(false)

  // Payout Configuration
  payoutEnabled         Boolean   @default(false)
  payoutWalletAddress   String?
  payoutWalletEncrypted String?
  payoutMilestonePoints Int       @default(100)
  payoutAmountUSD       Float     @default(5.0)
  payoutNetwork         String    @default("polygon")
  lastBalanceCheck      DateTime?
  usdcBalance           Float?
  lowBalanceAlertSent   Boolean   @default(false)
  lowBalanceThreshold   Float     @default(50.0)
  notificationEmail     String?

  // Member Limit Addons & Grace Period
  additionalMemberSlots     Int       @default(0) // Each slot = 500 members ($10 per slot)
  downgradeGracePeriodEndsAt DateTime? // 15-day grace period after downgrade
  previousPlan              String?   // Track what plan they downgraded from
  lastTrialEmailSent        Int?      // Track last trial expiring email sent (days remaining)

  // POS Integration (Secure OAuth Storage)
  squareAccessToken   String? // Encrypted Square OAuth token
  squareRefreshToken  String? // Encrypted refresh token
  squareLocationId    String?
  toastAccessToken    String? // Encrypted Toast OAuth token
  toastRefreshToken   String?
  toastRestaurantGuid String?
  cloverAccessToken   String? // Encrypted Clover OAuth token
  cloverMerchantId    String?
  shopifyAccessToken  String? // Encrypted Shopify OAuth token
  shopifyShopDomain   String?
  posPointsPerDollar  Float   @default(1.0) // Configurable points ratio

  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  businesses      Business[]
  events          Event[]
  staff           Staff[]
  merchantMembers MerchantMember[] // NEW: Merchant-level member relationships
  rewards         Reward[]         // Customizable rewards catalog
  tierConfigs     MemberTierConfig[] // Custom tier configurations (Growth/Pro)
  payoutMilestones PayoutMilestone[] // Multiple payout milestones (Growth/Pro)
  pointsConfigs   PointsConfig[]     // Custom points rules (Growth/Pro)
  payoutNotificationRequests PayoutNotificationRequest[] // Members waiting for funds
}

/// *
///  * Member = a real person (or account) in your system.
///  * Not tied to a single business anymore.
model Member {
  id        String  @id @default(cuid())
  firstName String  @default("")
  lastName  String  @default("")
  email     String  @unique
  phone     String?
  address   String?
  city      String?
  state     String? // Two-letter state code (CA, NY, etc.)
  zipCode   String?

  // Password authentication (optional - members can use magic link OR password OR wallet)
  passwordHash String?

  // Email preferences & verification
  emailVerified         Boolean   @default(false)
  emailVerifiedAt       DateTime?
  emailMarketingConsent Boolean   @default(true)

  walletAddress      String?
  tier               String              @default("STARTER")
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  businesses         BusinessMember[]
  events             Event[]
  loginTokens        MemberLoginToken[]
  rewardTransactions RewardTransaction[]
  scans              Scan[]
  memberWallet       MemberWallet?
  merchantMembers    MerchantMember[] // NEW: Merchant-level memberships
  payoutNotificationRequests PayoutNotificationRequest[] // Waiting for merchant funds
}

/// *
///  * Magic link tokens for passwordless member login
model MemberLoginToken {
  id        String    @id @default(cuid())
  token     String    @unique
  memberId  String
  expiresAt DateTime
  usedAt    DateTime?
  returnTo  String?
  createdAt DateTime  @default(now())
  member    Member    @relation(fields: [memberId], references: [id], onDelete: Cascade)
}

/// *
///  * MERCHANT-LEVEL membership - points aggregated across all merchant locations
///  * This is the PRIMARY points storage for multi-location merchants
model MerchantMember {
  id         String @id @default(cuid())
  merchantId String
  memberId   String

  // Merchant-level points (shared across all locations)
  points Int    @default(0)
  tier   String @default("BASE")

  // Wallet info (same across all merchant locations)
  walletAddress String?
  walletNetwork String?
  isCustodial   Boolean?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  member             Member              @relation(fields: [memberId], references: [id], onDelete: Cascade)
  merchant           Merchant            @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  rewardTransactions RewardTransaction[]

  @@unique([merchantId, memberId])
  @@index([merchantId])
  @@index([memberId])
}

/// *
///  * LOCATION-LEVEL tracking - visit history per business location
///  * Points are NOW tracked at MerchantMember level, not here
model BusinessMember {
  id         String @id @default(cuid())
  businessId String
  memberId   String

  // Per-location visit tracking (analytics only, not for points)
  visitCount   Int       @default(0)
  lastVisitAt  DateTime?
  firstVisitAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  member   Member   @relation(fields: [memberId], references: [id], onDelete: Cascade)
  business Business @relation(fields: [businessId], references: [id], onDelete: Cascade)

  @@unique([businessId, memberId])
  @@index([businessId])
  @@index([memberId])
}

/// *
///  * Event log for analytics / audit.
///  * Still attached to Merchant and optionally Member.
model Event {
  id         String    @id @default(cuid())
  merchantId String
  memberId   String?
  type       EventType
  metadata   Json?
  createdAt  DateTime  @default(now())
  source     String?
  member     Member?   @relation(fields: [memberId], references: [id])
  merchant   Merchant  @relation(fields: [merchantId], references: [id], onDelete: Cascade)
}

model RewardTransaction {
  id               String            @id @default(cuid())
  merchantMemberId String // NEW: Links to MerchantMember instead
  businessId       String // Which location the transaction occurred at
  memberId         String
  type             RewardType
  amount           Int // Points earned/redeemed
  pointsDeducted   Int?
  usdcAmount       Float?
  currency         String            @default("POINTS")
  reason           String?
  txHash           String?
  walletAddress    String?
  walletNetwork    String?
  status           TransactionStatus @default(PENDING)
  errorMessage     String?
  createdAt        DateTime          @default(now())
  member           Member            @relation(fields: [memberId], references: [id])
  business         Business          @relation(fields: [businessId], references: [id])
  merchantMember   MerchantMember    @relation(fields: [merchantMemberId], references: [id], onDelete: Cascade)

  @@index([merchantMemberId])
  @@index([businessId])
  @@index([memberId])
}

/// *
///  * Admin users - separate from merchants
///  * Can manage merchants, blog posts, and system settings
model Admin {
  id           String          @id @default(cuid())
  email        String          @unique
  passwordHash String
  fullName     String
  role         AdminRole       @default(ADMIN)
  isActive     Boolean         @default(true)
  createdAt    DateTime        @default(now())
  lastLoginAt  DateTime?
  auditLogs    AdminAuditLog[]
  blogPosts    BlogPost[]
}

/// *
///  * Blog posts - database-backed CMS
model BlogPost {
  id              String     @id @default(cuid())
  slug            String     @unique
  title           String
  description     String
  content         String
  metaTitle       String?
  metaDescription String?
  metaKeywords    String?
  ogImage         String?
  status          BlogStatus @default(DRAFT)
  publishedAt     DateTime?
  category        String
  readTimeMinutes Int        @default(5)
  authorId        String
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  author          Admin      @relation(fields: [authorId], references: [id])

  @@index([status, publishedAt])
}

/// *
///  * Staff members - per merchant employees
///  * Can manage loyalty program for their merchant
model Staff {
  id                String    @id @default(cuid())
  email             String    @unique
  passwordHash      String?   // Null until invite is accepted
  fullName          String
  merchantId        String
  canManageMembers  Boolean   @default(true)
  canViewReports    Boolean   @default(true)
  canManageSettings Boolean   @default(false)
  isActive          Boolean   @default(true)
  createdAt         DateTime  @default(now())
  lastLoginAt       DateTime?
  merchant          Merchant  @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  // Invitation system
  inviteToken       String?   @unique // Secure token for email invite link
  inviteExpiresAt   DateTime? // When the invite expires (7 days)
  inviteSentAt      DateTime? // When the invite email was sent
  inviteAcceptedAt  DateTime? // When staff accepted and set password
  invitedById       String?   // Merchant user who sent the invite

  @@index([merchantId])
  @@index([inviteToken])
}

/// *
///  * Password reset tokens - for merchants, staff, and admins
model PasswordResetToken {
  id        String    @id @default(cuid())
  token     String    @unique
  email     String
  userType  UserType
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([token])
}

/// *
///  * Admin audit log - track all admin actions for compliance
model AdminAuditLog {
  id         String   @id @default(cuid())
  adminId    String
  action     String
  entityType String
  entityId   String?
  changes    Json?
  ipAddress  String?
  createdAt  DateTime @default(now())
  admin      Admin    @relation(fields: [adminId], references: [id])

  @@index([adminId, createdAt])
}

/// *
///  * QR Codes - unique codes per business for member scanning
///  * Static QR codes with backend validation
model QRCode {
  id         String    @id @default(cuid())
  businessId String
  code       String    @unique
  signature  String
  isActive   Boolean   @default(true)
  createdAt  DateTime  @default(now())
  invalidAt  DateTime?
  business   Business  @relation(fields: [businessId], references: [id], onDelete: Cascade)
  scans      Scan[]

  @@index([businessId])
}

/// *
///  * Scans - track member QR scans with same-day restriction
///  * Status: pending (instant), confirmed (blockchain), failed
model Scan {
  id            String    @id @default(cuid())
  memberId      String
  businessId    String
  qrCodeId      String
  pointsAwarded Int
  txHash        String?
  status        String    @default("pending")
  scannedAt     DateTime  @default(now())
  confirmedAt   DateTime?
  member        Member    @relation(fields: [memberId], references: [id])
  business      Business  @relation(fields: [businessId], references: [id])
  qrCode        QRCode    @relation(fields: [qrCodeId], references: [id])

  @@index([memberId, scannedAt])
  @@index([businessId, scannedAt])
}

/// *
///  * Member custodial wallets - auto-generated for members
///  * Polygon network, encrypted private keys
model MemberWallet {
  id            String   @id @default(cuid())
  memberId      String   @unique
  walletAddress String   @unique
  privateKeyEnc String
  balance       Float    @default(0)
  network       String   @default("polygon")
  createdAt     DateTime @default(now())
  member        Member   @relation(fields: [memberId], references: [id], onDelete: Cascade)
}

/// *
///  * Reward - customizable rewards catalog per merchant
///  * Traditional rewards (in-store) or USDC payouts
model Reward {
  id          String     @id @default(cuid())
  merchantId  String
  name        String     // "Free Coffee", "10% Off", "$5 USDC"
  description String?    // "Any size, any blend"
  pointsCost  Int        // Points required to redeem
  rewardType  RewardKind @default(TRADITIONAL)
  usdcAmount  Float?     // For USDC payouts
  isActive    Boolean    @default(true)
  sortOrder   Int        @default(0) // For display ordering
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  merchant    Merchant   @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@index([merchantId])
}

/// *
///  * Custom member tier configurations per merchant (Growth/Pro plans)
///  * Allows adding more than 3 tiers with custom thresholds
model MemberTierConfig {
  id          String   @id @default(cuid())
  merchantId  String
  name        String   // "BASE", "SILVER", "GOLD", "PLATINUM", etc.
  displayName String   // "Base Member", "Silver Member", etc.
  description String?  // "Starter level", "Unlocked after 10 visits"
  threshold   Int      // Points required to reach this tier
  sortOrder   Int      @default(0)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  merchant    Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@unique([merchantId, name])
  @@index([merchantId])
}

/// *
///  * Multiple payout milestones per merchant (Growth/Pro plans)
///  * Allows different USDC amounts at different point thresholds
///  * Future: support multiple stablecoins and blockchain networks
model PayoutMilestone {
  id             String   @id @default(cuid())
  merchantId     String
  name           String   // "$5 USDC Payout", "$10 USDC Payout"
  pointsRequired Int      // Points needed to claim this milestone
  usdcAmount     Float    // Amount in USDC to pay out
  stablecoin     String   @default("USDC") // Future: USDT, DAI, etc.
  network        String   @default("polygon") // Future: eth, sol, xrp, base, etc.
  sortOrder      Int      @default(0)
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  merchant       Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@index([merchantId])
}

/// *
///  * Custom points configuration per merchant (Growth/Pro plans)
///  * Allows custom earn rules beyond basic visit points
model PointsConfig {
  id           String   @id @default(cuid())
  merchantId   String
  name         String   // "Visit Bonus", "Referral Bonus", "Birthday Bonus"
  triggerType  String   // "VISIT", "REFERRAL", "SPEND", "BIRTHDAY", "CUSTOM"
  pointsAmount Int      // Base points to award
  multiplier   Float    @default(1.0) // Optional multiplier
  conditions   Json?    // {"minSpend": 50, "dayOfWeek": "MONDAY"}
  sortOrder    Int      @default(0)
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  merchant     Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@index([merchantId])
}

enum RewardKind {
  TRADITIONAL // Redeemed in-store (free item, discount, etc.)
  USDC_PAYOUT // Crypto payout to member wallet
}

enum Plan {
  STARTER
  BASIC
  PREMIUM
  GROWTH
  PRO
}

enum EventType {
  SCAN
  CONNECT_WALLET
  CREATE_EMAIL
  REWARD_EARNED
  REWARD_REDEEMED
  PAYOUT_CLAIMED
  EMAIL_SENT
  LOW_BALANCE_ALERT
  PAYOUT_SUCCESS_NOTIFY
}

enum MerchantPlan {
  STARTER
  BASIC
  PREMIUM
  GROWTH
  PRO
}

// Track members who want to be notified when merchant has funds for payout
model PayoutNotificationRequest {
  id              String   @id @default(cuid())
  merchantId      String
  memberId        String
  memberEmail     String   // Store email for notification
  pointsEarned    Int      // Points they had when requesting
  payoutAmount    Float    // Amount they were trying to claim
  notified        Boolean  @default(false) // Has been notified
  notifiedAt      DateTime? // When notification was sent
  createdAt       DateTime @default(now())
  merchant        Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  member          Member   @relation(fields: [memberId], references: [id], onDelete: Cascade)

  @@unique([merchantId, memberId]) // One request per member per merchant
  @@index([merchantId])
  @@index([memberId])
}

enum MemberTier {
  BASE
  VIP
  SUPER
}

enum RewardType {
  EARN
  REDEEM
  ADJUST
  PAYOUT
}

enum TransactionStatus {
  PENDING
  SUCCESS
  FAILED
}

enum AdminRole {
  SUPER_ADMIN
  ADMIN
  EDITOR
}

enum BlogStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum UserType {
  MERCHANT
  STAFF
  ADMIN
  MEMBER
}

enum SubscriptionStatus {
  TRIAL // 7-day free trial
  ACTIVE // Paid and active
  PAST_DUE // Payment failed, grace period
  CANCELED // User canceled
  EXPIRED // Trial expired without payment
  PAUSED // Temporarily paused
}
