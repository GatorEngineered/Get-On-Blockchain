generator client {
  provider = "prisma-client-js"
}

datasource db {
  // Using PostgreSQL for both local dev and production
  // DATABASE_URL should be set in .env.local and Vercel environment variables

  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Business {
  id                 String              @id @default(cuid())
  slug               String              @unique
  name               String
  locationNickname   String?
  address            String // Street address
  suite              String? // Suite/Apt/Unit number
  city               String?
  state              String? // Two-letter state code for filtering
  zipCode            String?
  contactEmail       String
  industry           String? // "restaurant", "gym", "salon", "retail"

  // Business Hours (for rate limiting based on business days)
  businessOpenTime   String?  // 24-hour format "HH:mm" (e.g., "09:00")
  businessCloseTime  String?  // 24-hour format "HH:mm" (e.g., "21:00")
  businessDaysOpen   Json?    // Array of days open [0,1,2,3,4,5,6] where 0=Sunday
  businessTimezone   String   @default("America/Los_Angeles")

  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  merchantId         String?
  merchant           Merchant?           @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  members            BusinessMember[]
  rewardTransactions RewardTransaction[]
  qrCodes            QRCode[]
  scans              Scan[]
  redemptionRequests RedemptionRequest[] // QR-verified redemption requests at this location

  @@index([state])
  @@index([industry])
}

/// *
///  * Merchant is your internal "plan" / configuration object for the SaaS.
///  * You can keep using this for pricing plans, welcome points logic, etc.
model Merchant {
  id             String  @id @default(cuid())
  slug           String  @unique
  name           String
  tagline        String?
  plan           Plan    @default(STARTER)
  loginEmail     String  @unique
  passwordHash   String
  welcomePoints  Int     @default(10)
  earnPerVisit   Int     @default(10)
  vipThreshold   Int     @default(100)
  superThreshold Int     @default(200)
  customTierThresholds Json? // Custom thresholds for intermediate tiers (SERGEANT, CAPTAIN, MAJOR)
  primaryColor   String?
  accentColor    String?

  // Payment & Subscription (PayPal)
  paymentVerified      Boolean            @default(false)
  paypalSubscriptionId String?            @unique
  subscriptionStatus   SubscriptionStatus @default(TRIAL)
  trialEndsAt          DateTime?
  subscriptionEndsAt   DateTime?
  cancelAtPeriodEnd    Boolean            @default(false)

  // Payout Configuration
  payoutEnabled         Boolean   @default(false)
  payoutWalletAddress   String?
  payoutWalletEncrypted String?
  payoutMilestonePoints Int       @default(100)
  payoutAmountUSD       Float     @default(5.0)
  payoutNetwork         String    @default("polygon")
  lastBalanceCheck      DateTime?
  usdcBalance           Float?
  lowBalanceAlertSent   Boolean   @default(false)
  lowBalanceThreshold   Float     @default(50.0)
  notificationEmail     String?

  // Monthly USDC Budget Cap
  monthlyPayoutBudget     Float?    // Max USDC to pay out per month (null = unlimited)
  payoutBudgetResetDay    Int?      // Day of month to reset budget (1-28)
  currentMonthPayouts     Float     @default(0) // Running total USDC paid this cycle
  lastBudgetResetAt       DateTime? // When budget was last reset

  // Member Limit Addons & Grace Period
  additionalMemberSlots     Int       @default(0) // Each slot = 500 members ($10 per slot)
  downgradeGracePeriodEndsAt DateTime? // 15-day grace period after downgrade
  previousPlan              String?   // Track what plan they downgraded from
  lastTrialEmailSent        Int?      // Track last trial expiring email sent (days remaining)

  // POS Integration (Secure OAuth Storage)
  squareAccessToken   String? // Encrypted Square OAuth token
  squareRefreshToken  String? // Encrypted refresh token
  squareLocationId    String?
  toastAccessToken    String? // Encrypted Toast OAuth token
  toastRefreshToken   String?
  toastRestaurantGuid String?
  cloverAccessToken   String? // Encrypted Clover OAuth token
  cloverMerchantId    String?
  shopifyAccessToken  String? // Encrypted Shopify OAuth token
  shopifyShopDomain   String?
  vagaroClientId      String? // Encrypted Vagaro API client ID
  vagaroClientSecret  String? // Encrypted Vagaro API client secret
  vagaroBusinessId    String? // Vagaro business identifier (for webhook matching)
  posPointsPerDollar  Float   @default(1.0) // Configurable points ratio

  // Referral settings
  referralEnabled     Boolean @default(true)
  referralPointsValue Int     @default(50) // Points awarded when referral converts

  // Birthday & Anniversary Reward Settings
  birthdayRewardEnabled       Boolean @default(false)
  birthdayRewardPoints        Int     @default(50)
  birthdayRewardWindowDays    Int     @default(7)  // Days before/after birthday to claim
  birthdayRewardId            String? // Optional: Free reward from catalog instead of/in addition to points

  // Member Anniversary (based on join date / createdAt)
  memberAnniversaryRewardEnabled    Boolean @default(false)
  memberAnniversaryRewardPoints     Int     @default(50)
  memberAnniversaryRewardWindowDays Int     @default(7)  // Days before/after join anniversary to claim
  memberAnniversaryRewardId         String? // Optional: Free reward from catalog

  // Relationship Anniversary (wedding/relationship date set by member)
  relationshipAnniversaryRewardEnabled    Boolean @default(false)
  relationshipAnniversaryRewardPoints     Int     @default(50)
  relationshipAnniversaryRewardWindowDays Int     @default(7)  // Days before/after relationship anniversary to claim
  relationshipAnniversaryRewardId         String? // Optional: Free reward from catalog

  // Happy Hour / Time-based Multiplier Settings
  happyHourEnabled      Boolean @default(false)
  happyHourMultiplier   Float   @default(2.0)    // e.g., 2.0 = double points
  happyHourStartTime    String? // "14:00" (24-hour format HH:mm)
  happyHourEndTime      String? // "17:00" (24-hour format HH:mm)
  happyHourDaysOfWeek   Json?   // [0,1,2,3,4,5,6] where 0=Sunday, 6=Saturday
  happyHourTimezone     String  @default("America/Los_Angeles")

  // Social Media Links (for member dashboard display)
  instagramUrl    String?
  facebookUrl     String?
  twitterUrl      String?
  tiktokUrl       String?

  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  businesses      Business[]
  events          Event[]
  staff           Staff[]
  merchantMembers MerchantMember[] // NEW: Merchant-level member relationships
  rewards         Reward[]         // Customizable rewards catalog
  tierConfigs     MemberTierConfig[] // Custom tier configurations (Growth/Pro)
  payoutMilestones PayoutMilestone[] // Multiple payout milestones (Growth/Pro)
  pointsConfigs   PointsConfig[]     // Custom points rules (Growth/Pro)
  payoutNotificationRequests PayoutNotificationRequest[] // Members waiting for funds
  referrals       Referral[]       // Member referrals for this merchant
  redemptionRequests RedemptionRequest[] // QR-verified redemption requests
  merchantToken   MerchantToken?   // Branded token (Growth plan)
  eventQRCodes    EventQRCode[]    // Event-specific QR codes
  apiKeys         ApiKey[]         // External API keys (Premium+)
  externalOrders  ExternalOrder[]  // Orders from external systems
  pointsRules     PointsRule[]     // Custom points rules (product, category, action)
  socialEngagements SocialEngagement[] // Member social engagements
}

/// *
///  * Member = a real person (or account) in your system.
///  * Not tied to a single business anymore.
model Member {
  id        String  @id @default(cuid())
  firstName String  @default("")
  lastName  String  @default("")
  email     String  @unique
  phone     String?
  address   String?
  city      String?
  state     String? // Two-letter state code (CA, NY, etc.)
  zipCode   String?

  // Password authentication (optional - members can use magic link OR password OR wallet)
  passwordHash String?

  // Birthday & Anniversary (Special Rewards)
  birthMonth      Int?              // 1-12
  birthDay        Int?              // 1-31
  birthYear       Int?              // Full year (private - merchants only see month/day for rewards)
  birthdayLocked  Boolean @default(false) // Once set, cannot be changed
  anniversaryDate DateTime?         // Relationship/Wedding anniversary date (month, day, year)

  // Email preferences & verification
  emailVerified         Boolean   @default(false)
  emailVerifiedAt       DateTime?
  emailMarketingConsent Boolean   @default(true) // Legacy field, kept for backwards compatibility

  // System notification preferences (from Get On Blockchain platform)
  emailPayoutNotifications  Boolean @default(true)  // Payout confirmations
  emailMagicLinkEnabled     Boolean @default(true)  // Magic link emails (if false, must use password)
  emailSecurityAlerts       Boolean @default(true)  // Account security alerts (always sent for critical)

  // Merchant notification preferences (from businesses they're members of)
  emailMerchantPromotional  Boolean @default(true)  // Promotional offers from merchants
  emailMerchantPointsUpdates Boolean @default(true) // Points earned, tier updates
  emailMerchantAnnouncements Boolean @default(true) // Special announcements from businesses

  walletAddress      String?
  tier               String              @default("STARTER")
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  businesses         BusinessMember[]
  events             Event[]
  loginTokens        MemberLoginToken[]
  rewardTransactions RewardTransaction[]
  scans              Scan[]
  memberWallet       MemberWallet?
  merchantMembers    MerchantMember[] // NEW: Merchant-level memberships
  payoutNotificationRequests PayoutNotificationRequest[] // Waiting for merchant funds
  referralsSent      Referral[]       // Referrals this member has sent
  redemptionRequests RedemptionRequest[] // QR-verified redemption requests
  tokenBalances      TokenBalance[]   // Branded token balances
  tokenTransactions  TokenTransaction[] // Token transaction history
  eventScans         EventScan[]      // Event QR code scans
  externalOrders     ExternalOrder[]  // Orders linked to this member
  socialEngagements  SocialEngagement[] // Social media engagements
}

/// *
///  * Magic link tokens for passwordless member login
model MemberLoginToken {
  id        String    @id @default(cuid())
  token     String    @unique
  memberId  String
  expiresAt DateTime
  usedAt    DateTime?
  returnTo  String?
  createdAt DateTime  @default(now())
  member    Member    @relation(fields: [memberId], references: [id], onDelete: Cascade)
}

/// *
///  * MERCHANT-LEVEL membership - points aggregated across all merchant locations
///  * This is the PRIMARY points storage for multi-location merchants
model MerchantMember {
  id         String @id @default(cuid())
  merchantId String
  memberId   String

  // Merchant-level points (shared across all locations)
  points Int    @default(0)
  tier   String @default("BASE")

  // Wallet info (same across all merchant locations)
  walletAddress String?
  walletNetwork String?
  isCustodial   Boolean?

  // Special Rewards Claim Tracking (one claim per year)
  lastBirthdayClaimYear              Int? // e.g., 2026 - prevents double claim same year
  lastMemberAnniversaryClaimYear     Int? // For membership anniversary (join date)
  lastRelationshipAnniversaryClaimYear Int? // For relationship/wedding anniversary

  // Referral Code (unique shareable link)
  referralCode String? @unique // 8-char alphanumeric code e.g., "ABC12345"

  // USDC Payout Tracking (one claim per budget cycle)
  lastPayoutClaimCycleStart DateTime? // Start of budget cycle when member last claimed USDC

  // Member & Merchant Notes
  memberNote   String? // Member's note about themselves (300 char max, visible to merchant)
  merchantNote String? // Merchant's private note about the member (not visible to member)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  member             Member              @relation(fields: [memberId], references: [id], onDelete: Cascade)
  merchant           Merchant            @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  rewardTransactions RewardTransaction[]

  @@unique([merchantId, memberId])
  @@index([merchantId])
  @@index([memberId])
}

/// *
///  * LOCATION-LEVEL tracking - visit history per business location
///  * Points are NOW tracked at MerchantMember level, not here
model BusinessMember {
  id         String @id @default(cuid())
  businessId String
  memberId   String

  // Per-location visit tracking (analytics only, not for points)
  visitCount   Int       @default(0)
  lastVisitAt  DateTime?
  firstVisitAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  member   Member   @relation(fields: [memberId], references: [id], onDelete: Cascade)
  business Business @relation(fields: [businessId], references: [id], onDelete: Cascade)

  @@unique([businessId, memberId])
  @@index([businessId])
  @@index([memberId])
}

/// *
///  * Event log for analytics / audit.
///  * Still attached to Merchant and optionally Member.
model Event {
  id         String    @id @default(cuid())
  merchantId String
  memberId   String?
  type       EventType
  metadata   Json?
  createdAt  DateTime  @default(now())
  source     String?
  member     Member?   @relation(fields: [memberId], references: [id])
  merchant   Merchant  @relation(fields: [merchantId], references: [id], onDelete: Cascade)
}

model RewardTransaction {
  id               String            @id @default(cuid())
  merchantMemberId String // NEW: Links to MerchantMember instead
  businessId       String // Which location the transaction occurred at
  memberId         String
  type             RewardType
  amount           Int // Points earned/redeemed
  pointsDeducted   Int?
  usdcAmount       Float?
  currency         String            @default("POINTS")
  reason           String?
  txHash           String?
  walletAddress    String?
  walletNetwork    String?
  status           TransactionStatus @default(PENDING)
  errorMessage     String?
  createdAt        DateTime          @default(now())
  member           Member            @relation(fields: [memberId], references: [id])
  business         Business          @relation(fields: [businessId], references: [id])
  merchantMember   MerchantMember    @relation(fields: [merchantMemberId], references: [id], onDelete: Cascade)

  @@index([merchantMemberId])
  @@index([businessId])
  @@index([memberId])
}

/// *
///  * Admin users - separate from merchants
///  * Can manage merchants, blog posts, and system settings
model Admin {
  id           String          @id @default(cuid())
  email        String          @unique
  passwordHash String
  fullName     String
  role         AdminRole       @default(ADMIN)
  isActive     Boolean         @default(true)
  createdAt    DateTime        @default(now())
  lastLoginAt  DateTime?
  auditLogs    AdminAuditLog[]
  blogPosts    BlogPost[]
}

/// *
///  * Blog posts - database-backed CMS
model BlogPost {
  id              String     @id @default(cuid())
  slug            String     @unique
  title           String
  description     String
  content         String
  metaTitle       String?
  metaDescription String?
  metaKeywords    String?
  ogImage         String?
  status          BlogStatus @default(DRAFT)
  publishedAt     DateTime?
  category        String
  readTimeMinutes Int        @default(5)
  authorId        String
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  author          Admin      @relation(fields: [authorId], references: [id])

  @@index([status, publishedAt])
}

/// *
///  * Staff members - per merchant employees
///  * Can manage loyalty program for their merchant
model Staff {
  id                String    @id @default(cuid())
  email             String    @unique
  passwordHash      String?   // Null until invite is accepted
  fullName          String
  merchantId        String
  canManageMembers  Boolean   @default(true)
  canViewReports    Boolean   @default(true)
  canManageSettings Boolean   @default(false)
  isActive          Boolean   @default(true)
  createdAt         DateTime  @default(now())
  lastLoginAt       DateTime?
  merchant          Merchant  @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  // Invitation system
  inviteToken       String?   @unique // Secure token for email invite link
  inviteExpiresAt   DateTime? // When the invite expires (7 days)
  inviteSentAt      DateTime? // When the invite email was sent
  inviteAcceptedAt  DateTime? // When staff accepted and set password
  invitedById       String?   // Merchant user who sent the invite

  // Redemption confirmations
  confirmedRedemptions RedemptionRequest[] // Redemptions this staff confirmed

  @@index([merchantId])
  @@index([inviteToken])
}

/// *
///  * Password reset tokens - for merchants, staff, and admins
model PasswordResetToken {
  id        String    @id @default(cuid())
  token     String    @unique
  email     String
  userType  UserType
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([token])
}

/// *
///  * Admin audit log - track all admin actions for compliance
model AdminAuditLog {
  id         String   @id @default(cuid())
  adminId    String
  action     String
  entityType String
  entityId   String?
  changes    Json?
  ipAddress  String?
  createdAt  DateTime @default(now())
  admin      Admin    @relation(fields: [adminId], references: [id])

  @@index([adminId, createdAt])
}

/// *
///  * QR Codes - unique codes per business for member scanning
///  * Static QR codes with backend validation
model QRCode {
  id         String    @id @default(cuid())
  businessId String
  code       String    @unique
  signature  String
  isActive   Boolean   @default(true)
  createdAt  DateTime  @default(now())
  invalidAt  DateTime?
  business   Business  @relation(fields: [businessId], references: [id], onDelete: Cascade)
  scans      Scan[]

  @@index([businessId])
}

/// *
///  * Scans - track member QR scans with same-day restriction
///  * Status: pending (instant), confirmed (blockchain), failed
model Scan {
  id            String    @id @default(cuid())
  memberId      String
  businessId    String
  qrCodeId      String
  pointsAwarded Int
  txHash        String?
  status        String    @default("pending")
  scannedAt     DateTime  @default(now())
  confirmedAt   DateTime?
  member        Member    @relation(fields: [memberId], references: [id])
  business      Business  @relation(fields: [businessId], references: [id])
  qrCode        QRCode    @relation(fields: [qrCodeId], references: [id])

  @@index([memberId, scannedAt])
  @@index([businessId, scannedAt])
}

/// *
///  * Member wallets - auto-generated for members (hybrid custody)
///  * Starts custodial, member can export to take full control
///  * Polygon network, encrypted private keys
model MemberWallet {
  id            String     @id @default(cuid())
  memberId      String     @unique
  walletAddress String     @unique
  privateKeyEnc String     // Encrypted private key (null after export if non-custodial)
  balance       Float      @default(0) // USDC balance for payouts
  network       String     @default("polygon")

  // Hybrid custody support
  walletType    WalletType @default(CUSTODIAL)
  isExported    Boolean    @default(false) // Has member exported their keys?
  exportedAt    DateTime?  // When member claimed full ownership

  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  member        Member     @relation(fields: [memberId], references: [id], onDelete: Cascade)
}

/// *
///  * Reward - customizable rewards catalog per merchant
///  * Traditional rewards (in-store), USDC payouts, or token redemptions
model Reward {
  id          String     @id @default(cuid())
  merchantId  String
  name        String     // "Free Coffee", "10% Off", "$5 USDC"
  description String?    // "Any size, any blend"
  pointsCost  Int        // Points required to redeem
  rewardType  RewardKind @default(TRADITIONAL)
  usdcAmount  Float?     // For USDC payouts
  tokenCost   Int?       // For TOKEN_REWARD: tokens to burn
  isActive    Boolean    @default(true)
  sortOrder   Int        @default(0) // For display ordering
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  merchant    Merchant   @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  redemptionRequests RedemptionRequest[] // QR-verified redemption requests

  @@index([merchantId])
}

/// *
///  * Custom member tier configurations per merchant (Growth/Pro plans)
///  * Allows adding more than 3 tiers with custom thresholds
model MemberTierConfig {
  id          String   @id @default(cuid())
  merchantId  String
  name        String   // "BASE", "SILVER", "GOLD", "PLATINUM", etc.
  displayName String   // "Base Member", "Silver Member", etc.
  description String?  // "Starter level", "Unlocked after 10 visits"
  threshold   Int      // Points required to reach this tier
  sortOrder   Int      @default(0)
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  merchant    Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@unique([merchantId, name])
  @@index([merchantId])
}

/// *
///  * Multiple payout milestones per merchant (Growth/Pro plans)
///  * Allows different USDC amounts at different point thresholds
///  * Future: support multiple stablecoins and blockchain networks
model PayoutMilestone {
  id             String   @id @default(cuid())
  merchantId     String
  name           String   // "$5 USDC Payout", "$10 USDC Payout"
  pointsRequired Int      // Points needed to claim this milestone
  usdcAmount     Float    // Amount in USDC to pay out
  stablecoin     String   @default("USDC") // Future: USDT, DAI, etc.
  network        String   @default("polygon") // Future: eth, sol, xrp, base, etc.
  sortOrder      Int      @default(0)
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  merchant       Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@index([merchantId])
}

/// *
///  * Custom points configuration per merchant (Growth/Pro plans)
///  * Allows custom earn rules beyond basic visit points
model PointsConfig {
  id           String   @id @default(cuid())
  merchantId   String
  name         String   // "Visit Bonus", "Referral Bonus", "Birthday Bonus"
  triggerType  String   // "VISIT", "REFERRAL", "SPEND", "BIRTHDAY", "CUSTOM"
  pointsAmount Int      // Base points to award
  multiplier   Float    @default(1.0) // Optional multiplier
  conditions   Json?    // {"minSpend": 50, "dayOfWeek": "MONDAY"}
  sortOrder    Int      @default(0)
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  merchant     Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@index([merchantId])
}

/// *
///  * Referral - track member referrals for earning bonus points
///  * Member enters friend's email, gets points when friend signs up
model Referral {
  id            String         @id @default(cuid())
  referrerId    String         // Member who sent the referral
  merchantId    String         // Merchant context for the referral
  referredEmail String         // Email address of referred friend
  status        ReferralStatus @default(PENDING)
  pointsAwarded Int?           // Points given when converted (null until converted)
  source        String?        // How referral was shared: "email", "link", "twitter", "facebook", "whatsapp", "copy"
  createdAt     DateTime       @default(now())
  convertedAt   DateTime?      // When the referral was converted (friend signed up)

  referrer Member   @relation(fields: [referrerId], references: [id], onDelete: Cascade)
  merchant Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)

  @@unique([referrerId, merchantId, referredEmail]) // One referral per email per merchant per member
  @@index([referrerId])
  @@index([merchantId])
  @@index([referredEmail])
  @@index([status])
}

enum ReferralStatus {
  PENDING   // Waiting for friend to sign up
  CONVERTED // Friend signed up, points awarded
  EXPIRED   // Referral expired (optional: can add expiry logic later)
}

enum RewardKind {
  TRADITIONAL  // Redeemed in-store (free item, discount, etc.)
  USDC_PAYOUT  // Crypto payout to member wallet
  TOKEN_REWARD // Redeemed with branded tokens (Growth plan)
}

enum Plan {
  STARTER
  BASIC
  PREMIUM
  GROWTH
  PRO
}

enum EventType {
  SCAN
  EVENT_SCAN
  CONNECT_WALLET
  CREATE_EMAIL
  REWARD_EARNED
  REWARD_REDEEMED
  PAYOUT_CLAIMED
  EMAIL_SENT
  LOW_BALANCE_ALERT
  PAYOUT_SUCCESS_NOTIFY
  REFERRAL_SENT
  REFERRAL_CONVERTED
  BIRTHDAY_REWARD
  MEMBER_ANNIVERSARY_REWARD
  RELATIONSHIP_ANNIVERSARY_REWARD
}

enum MerchantPlan {
  STARTER
  BASIC
  PREMIUM
  GROWTH
  PRO
}

// Track members who want to be notified when merchant has funds/budget for payout
model PayoutNotificationRequest {
  id              String   @id @default(cuid())
  merchantId      String
  memberId        String
  memberEmail     String   // Store email for notification
  pointsEarned    Int      // Points they had when requesting
  payoutAmount    Float    // Amount they were trying to claim
  notificationType String  @default("low_balance") // "low_balance" or "budget_exhausted"
  budgetCycleStart DateTime? // For budget_exhausted: cycle they were blocked in
  notifyAfter     DateTime? // For budget_exhausted: 3 days after reset date
  notified        Boolean  @default(false) // Has been notified
  notifiedAt      DateTime? // When notification was sent
  createdAt       DateTime @default(now())
  merchant        Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  member          Member   @relation(fields: [memberId], references: [id], onDelete: Cascade)

  @@unique([merchantId, memberId, notificationType]) // One request per type per member per merchant
  @@index([merchantId])
  @@index([memberId])
  @@index([notifyAfter])
}

enum MemberTier {
  BASE
  VIP
  SUPER
}

enum RewardType {
  EARN
  REDEEM
  ADJUST
  PAYOUT
}

enum TransactionStatus {
  PENDING
  SUCCESS
  FAILED
}

enum AdminRole {
  SUPER_ADMIN
  ADMIN
  EDITOR
}

enum BlogStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

enum UserType {
  MERCHANT
  STAFF
  ADMIN
  MEMBER
}

enum SubscriptionStatus {
  TRIAL // 7-day free trial
  ACTIVE // Paid and active
  PAST_DUE // Payment failed, grace period
  CANCELED // User canceled
  EXPIRED // Trial expired without payment
  PAUSED // Temporarily paused
}

/// *
///  * Redemption Request - QR-verified reward redemptions
///  * Member generates QR, staff scans to verify & confirm
///  * Supports points, USDC, and future token redemptions
model RedemptionRequest {
  id              String            @id @default(cuid())
  merchantId      String
  memberId        String
  rewardId        String            // Which reward being redeemed
  businessId      String?           // Optional: which location (for multi-location merchants)

  // Cost tracking
  pointsCost      Int               // Points required
  usdcCost        Float?            // For USDC rewards
  tokenCost       Int?              // Future: for branded token rewards

  // QR verification
  qrCodeHash      String            @unique // Unique hash embedded in QR
  expiresAt       DateTime          // 5-10 min from creation

  // Status tracking
  status          RedemptionStatus  @default(PENDING)
  confirmedAt     DateTime?
  confirmedByStaffId String?        // Staff member who confirmed
  declinedAt      DateTime?
  declineReason   String?

  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  // Relations
  merchant        Merchant          @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  member          Member            @relation(fields: [memberId], references: [id], onDelete: Cascade)
  reward          Reward            @relation(fields: [rewardId], references: [id], onDelete: Cascade)
  business        Business?         @relation(fields: [businessId], references: [id], onDelete: SetNull)
  confirmedByStaff Staff?           @relation(fields: [confirmedByStaffId], references: [id], onDelete: SetNull)

  @@index([merchantId])
  @@index([memberId])
  @@index([status])
  @@index([qrCodeHash])
  @@index([expiresAt])
}

enum RedemptionStatus {
  PENDING   // QR generated, waiting for staff scan
  CONFIRMED // Staff confirmed, points deducted
  DECLINED  // Staff declined
  EXPIRED   // QR expired (not scanned in time)
  CANCELLED // Member cancelled before scanning
}

// ============================================================================
// BRANDED TOKEN SYSTEM (Growth Plan)
// ============================================================================

/// *
///  * MerchantToken - Branded ERC-20 token for Growth plan merchants
///  * One token per merchant, deployed on Polygon
model MerchantToken {
  id              String   @id @default(cuid())
  merchantId      String   @unique // One token per merchant

  // Token metadata
  tokenName       String   // "Joe's Coffee Token"
  tokenSymbol     String   // "JCFT" (3-5 chars)
  decimals        Int      @default(0) // Whole tokens only

  // Blockchain deployment
  contractAddress String?  // Polygon contract address (null until deployed)
  network         String   @default("polygon-amoy") // polygon-amoy (testnet) or polygon (mainnet)
  deployTxHash    String?  // Deployment transaction hash
  deployedAt      DateTime?

  // Supply tracking (cached from on-chain)
  totalMinted     Int      @default(0)
  totalBurned     Int      @default(0)
  circulatingSupply Int    @default(0) // minted - burned
  lastSyncedAt    DateTime?

  // Status
  isActive        Boolean  @default(true)
  isPaused        Boolean  @default(false) // Emergency pause

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  merchant        Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  tokenBalances   TokenBalance[]
  tokenTransactions TokenTransaction[]

  @@index([contractAddress])
}

/// *
///  * TokenBalance - Member's balance of a specific merchant token
///  * Cached from on-chain, synced periodically
model TokenBalance {
  id              String   @id @default(cuid())
  merchantTokenId String
  memberId        String

  // Balance (cached from on-chain)
  balance         Int      @default(0)
  lastSyncedAt    DateTime?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  merchantToken   MerchantToken @relation(fields: [merchantTokenId], references: [id], onDelete: Cascade)
  member          Member        @relation(fields: [memberId], references: [id], onDelete: Cascade)

  @@unique([merchantTokenId, memberId])
  @@index([merchantTokenId])
  @@index([memberId])
}

/// *
///  * TokenTransaction - On-chain token transactions
///  * Tracks mints, transfers, and burns
model TokenTransaction {
  id              String   @id @default(cuid())
  merchantTokenId String
  memberId        String?  // Null for contract deployment

  // Transaction type
  type            TokenTxType
  amount          Int      // Tokens minted/transferred/burned

  // Blockchain details
  txHash          String?  // Polygon transaction hash
  fromAddress     String?  // Sender address (null for mint)
  toAddress       String?  // Receiver address (null for burn)
  blockNumber     Int?

  // Status tracking
  status          TokenTxStatus @default(PENDING)
  errorMessage    String?
  confirmedAt     DateTime?

  // Gas tracking (for analytics)
  gasUsed         Int?
  gasPriceGwei    Float?

  // Context
  reason          String?  // "Earned from visit", "Redeemed reward", etc.
  relatedEntityId String?  // scanId, redemptionId, etc.

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  merchantToken   MerchantToken @relation(fields: [merchantTokenId], references: [id], onDelete: Cascade)
  member          Member?       @relation(fields: [memberId], references: [id], onDelete: SetNull)

  @@index([merchantTokenId])
  @@index([memberId])
  @@index([txHash])
  @@index([status])
}

enum TokenTxType {
  DEPLOY    // Contract deployment
  MINT      // New tokens created (earn)
  TRANSFER  // Token transfer between members
  BURN      // Tokens destroyed (redeem)
}

enum TokenTxStatus {
  PENDING   // Transaction submitted
  CONFIRMED // Transaction confirmed on-chain
  FAILED    // Transaction failed
}

enum WalletType {
  CUSTODIAL      // GOB manages keys, member can export
  NON_CUSTODIAL  // Member exported keys, full control
}

// ============================================================================
// EVENT QR CODE SYSTEM
// ============================================================================

/// *
///  * EventQRCode - Special QR codes for merchant events
///  * One-time scan per member per event, expires after event ends
model EventQRCode {
  id              String   @id @default(cuid())
  merchantId      String

  // Event details
  name            String   // "VIP Tasting Night", "Grand Opening", etc.
  description     String?  // Optional event description

  // Event timing
  eventDate       DateTime // The date of the event
  scanWindowStart DateTime // When members can start scanning
  scanWindowEnd   DateTime // When scanning ends (QR expires after this)

  // Rewards
  pointsAwarded   Int      @default(50) // Points for attending/scanning

  // QR Code data (same pattern as regular QR codes)
  code            String   @unique // Unique QR code string
  signature       String   // HMAC signature for verification

  // Status
  isActive        Boolean  @default(true)

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  merchant        Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  eventScans      EventScan[]

  @@index([merchantId])
  @@index([eventDate])
  @@index([scanWindowEnd])
}

/// *
///  * EventScan - Track member scans of event QR codes
///  * Enforces one scan per member per event
model EventScan {
  id              String   @id @default(cuid())
  eventQRCodeId   String
  memberId        String

  // Points and blockchain
  pointsAwarded   Int
  txHash          String?  // Token minting transaction hash (Growth/Pro)
  status          String   @default("pending") // pending, confirmed, failed

  scannedAt       DateTime @default(now())
  confirmedAt     DateTime?

  // Relations
  eventQRCode     EventQRCode @relation(fields: [eventQRCodeId], references: [id], onDelete: Cascade)
  member          Member      @relation(fields: [memberId], references: [id], onDelete: Cascade)

  // Ensure one scan per member per event
  @@unique([eventQRCodeId, memberId])
  @@index([memberId])
  @@index([eventQRCodeId])
}

// ============================================================================
// EXTERNAL API INTEGRATION SYSTEM (Premium+)
// ============================================================================

/// *
///  * ApiKey - Secure API keys for external integrations
///  * Allows merchants to integrate with their own systems (Shopify, WooCommerce, custom)
model ApiKey {
  id              String   @id @default(cuid())
  merchantId      String

  // Key details
  name            String   // "Shopify Integration", "Website Widget", etc.
  keyPrefix       String   // First 8 chars shown: "gob_live_abc12345..."
  keyHash         String   // SHA-256 hash of full key (never store plaintext!)

  // Permissions (what this key can do)
  permissions     Json     @default("[\"read:members\", \"write:points\", \"read:rewards\"]")
  // Available: read:members, write:members, read:points, write:points,
  //            read:rewards, write:rewards, read:orders, write:orders

  // Rate limiting
  rateLimit       Int      @default(1000) // Requests per hour

  // Security
  lastUsedAt      DateTime?
  lastUsedIP      String?
  isActive        Boolean  @default(true)
  expiresAt       DateTime? // Optional expiration

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  merchant        Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  apiUsageLogs    ApiUsageLog[]

  @@index([merchantId])
  @@index([keyHash])
  @@index([keyPrefix])
}

/// *
///  * ApiUsageLog - Track API usage for rate limiting and analytics
model ApiUsageLog {
  id          String   @id @default(cuid())
  apiKeyId    String

  // Request details
  endpoint    String   // "/api/v1/points/award"
  method      String   // "POST"
  statusCode  Int      // 200, 400, 401, etc.

  // Performance
  responseTime Int?    // Milliseconds

  // Client info
  ipAddress   String?
  userAgent   String?

  createdAt   DateTime @default(now())

  // Relations
  apiKey      ApiKey   @relation(fields: [apiKeyId], references: [id], onDelete: Cascade)

  @@index([apiKeyId])
  @@index([createdAt])
  @@index([endpoint])
}

/// *
///  * ExternalOrder - Orders received via webhook or API
///  * Used to award points for external e-commerce transactions
model ExternalOrder {
  id              String   @id @default(cuid())
  merchantId      String

  // External reference
  externalId      String   // Order ID from external system
  externalSource  String   // "shopify", "woocommerce", "webhook", "api"

  // Customer matching
  customerEmail   String
  memberId        String?  // Linked member (null if not found/created)

  // Order details
  orderTotal      Float    // Total order amount
  currency        String   @default("USD")
  orderDate       DateTime @default(now())

  // Points awarded
  pointsAwarded   Int?     // Points given for this order
  pointsAwardedAt DateTime?

  // Status
  status          String   @default("pending") // pending, processed, failed, duplicate
  errorMessage    String?

  // Product-level data (optional, for product-specific points)
  lineItems       Json?    // [{ sku, name, quantity, price, category }]

  // Idempotency
  idempotencyKey  String?  @unique // Prevent duplicate processing

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  merchant        Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  member          Member?  @relation(fields: [memberId], references: [id], onDelete: SetNull)

  @@unique([merchantId, externalId, externalSource])
  @@index([merchantId])
  @@index([customerEmail])
  @@index([memberId])
  @@index([status])
}

/// *
///  * PointsRule - Custom points rules for products, categories, or actions
///  * Allows merchants to set bonus points for specific items or behaviors
model PointsRule {
  id              String   @id @default(cuid())
  merchantId      String

  // Rule name/description
  name            String   // "Double Points on Dresses", "Follow Instagram Bonus"
  description     String?

  // Rule type
  ruleType        String   // "product", "category", "action", "time"

  // Targeting (depends on ruleType)
  // For product: { sku: "ABC123" } or { skus: ["ABC", "DEF"] }
  // For category: { category: "dresses" } or { categories: ["shoes", "bags"] }
  // For action: { action: "instagram_follow" } or { action: "review" }
  // For time: { startTime: "14:00", endTime: "17:00", days: [1,2,3,4,5] }
  targetConfig    Json

  // Reward configuration
  pointsType      String   @default("multiplier") // "multiplier", "bonus", "fixed"
  // multiplier: multiply base points (2.0 = double)
  // bonus: add flat bonus points
  // fixed: override with fixed points amount
  pointsValue     Float    // 2.0 for double, 50 for bonus, etc.

  // Validity
  startDate       DateTime?
  endDate         DateTime?
  isActive        Boolean  @default(true)

  // Limits
  maxUsesTotal    Int?     // Max times this rule can be used total
  maxUsesPerMember Int?    // Max times per member
  currentUses     Int      @default(0)

  // Priority (higher = applied first)
  priority        Int      @default(0)

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  merchant        Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  pointsRuleUsages PointsRuleUsage[]

  @@index([merchantId])
  @@index([ruleType])
  @@index([isActive])
}

/// *
///  * PointsRuleUsage - Track usage of points rules
model PointsRuleUsage {
  id              String   @id @default(cuid())
  pointsRuleId    String
  memberId        String

  // What triggered the rule
  triggeredBy     String?  // orderId, scanId, actionId, etc.
  pointsAwarded   Int      // Points given from this rule

  usedAt          DateTime @default(now())

  // Relations
  pointsRule      PointsRule @relation(fields: [pointsRuleId], references: [id], onDelete: Cascade)

  @@index([pointsRuleId])
  @@index([memberId])
}

/// *
///  * SocialEngagement - Track member social media engagements for points
///  * Members earn points for following, sharing, reviewing, etc.
model SocialEngagement {
  id              String   @id @default(cuid())
  merchantId      String
  memberId        String

  // Engagement details
  engagementType  String   // "instagram_follow", "facebook_follow", "twitter_follow",
                           // "tiktok_follow", "google_review", "share", "photo_upload"

  // Verification
  proofUrl        String?  // URL to the review, post, etc.
  verificationMethod String @default("self_reported") // "self_reported", "oauth", "manual"
  isVerified      Boolean  @default(false)
  verifiedAt      DateTime?
  verifiedBy      String?  // Staff ID who verified (for manual)

  // Points
  pointsAwarded   Int?     // Points given (null if pending verification)
  pointsAwardedAt DateTime?

  // Status
  status          String   @default("pending") // pending, approved, rejected
  rejectionReason String?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  merchant        Merchant @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  member          Member   @relation(fields: [memberId], references: [id], onDelete: Cascade)

  // Prevent duplicate claims
  @@unique([merchantId, memberId, engagementType])
  @@index([merchantId])
  @@index([memberId])
  @@index([engagementType])
  @@index([status])
}
